{
  "hash": "4ee37fbbf68bbbb526e8d62a26f394f4",
  "result": {
    "markdown": "# Statistical simulation and limit theorems\n\n## Curriculum\n\n### Core readings\n\n1.  Dekking et al., Chapter 13: The law of large numbers\n\n2.  Dekking et al., Chapter 14: The central limit theorem\n\n### Simulation in Python\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport scipy as sp\n```\n:::\n\n\n#### Random number generators\nWe start by defining an random number generator (*rng*). Computers are not able to generate truly random numbers. Instead they generate so-called [pseudo-random numbers](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) using methods such as the [linear congruential generator](https://en.wikipedia.org/wiki/Linear_congruential_generator). \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nrng = np.random.default_rng(seed = 313)\nrng\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nGenerator(PCG64) at 0x23F134C0120\n```\n:::\n:::\n\n\nAs you can see, the object `rng` is a `Generator(PCG64)`, i.e., a random number generator.\n\nGenerator objects have methods to generate random values.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nrng.uniform(0, 1, size = 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([0.63182242, 0.46427464, 0.77927765, 0.40253182, 0.61196237,\n       0.32392294, 0.10567386, 0.68671495, 0.01786417, 0.60813899])\n```\n:::\n:::\n\n\nThis code generates a column vector of ten elements randomly sampled from the uniform distribution on $[0,1]$. The `size` argument is a dimension, hence you can write:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nrng.uniform(0, 1, size = (2, 10))\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([[0.77322932, 0.23260444, 0.56660324, 0.96823875, 0.93026402,\n        0.71578432, 0.29358623, 0.53439132, 0.81535993, 0.42267216],\n       [0.96857697, 0.96626312, 0.24506702, 0.44363894, 0.45995697,\n        0.86179148, 0.45618709, 0.90139015, 0.51322552, 0.93442797]])\n```\n:::\n:::\n\n\nThis is an array with $2$ rows and $10$ columns.\n\nOur generator `rng` was defined using the argument `seed = 313`. This is used for *reproducibility*. If you run the same code twice with the same seed, the result is going to be the same.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nrng1 = np.random.default_rng(seed = 313)\nrng2 = np.random.default_rng(seed = 313)\nrng1.uniform(0, 1, size = (2, 2))\nrng2.uniform(0, 1, size = (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\narray([[0.63182242, 0.46427464],\n       [0.77927765, 0.40253182]])\n```\n:::\n:::\n\n\nBut the results will not be the same if we do not provide the seed!\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nrng1 = np.random.default_rng()\nrng2 = np.random.default_rng()\nrng1.uniform(0, 1, size = (2, 2))\nrng2.uniform(0, 1, size = (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([[0.52069292, 0.56979936],\n       [0.68525224, 0.93548289]])\n```\n:::\n:::\n\n\nThe first two first arguments of `rng.uniform` specify the start point and end point of the interval we sample from.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nrng1 = np.random.default_rng(seed = 313)\nrng2 = np.random.default_rng(seed = 313)\nx = rng1.uniform(2, 5, size = (2, 2)) # starting at 2 and ending at 5,\ny = rng2.uniform(0, 1, size = (2, 2)) # starting at 0 and ending at 1.\n\nx\n3*y + 2\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([[3.89546727, 3.39282392],\n       [4.33783294, 3.20759547]])\n```\n:::\n:::\n\n\nNow $x$ and $y$ are the same. This will always be the case.\n\n##### Quick exercise\n\nGenerate an array of uniformly distributed numbers on $[1,5]$ with $3$ rows and $4$ columns.\n\n#### Using distributions\n\nThe Generator object supports random sampling from many distributions. See [the documenation](https://numpy.org/doc/stable/reference/random/generator.html#distributions) for a complete list.\n\nFor instance, you can generate normally distributed random values (with mean `mu` and standard deviation `sigma`) using `rng.normal(mu, sigma, size)`. Again, the `size` argument tells `numpy` how many rows, columns and potentially more dimensions you want your array to have.\n\n| Function   | Distribution | \n| --------   | ------------ |\n| `integers` | Random integers from low (inclusive) to high (exclusive).\n| `choice`   | Sample from an array with or without replacement.\n| `uniform`  | Uniformly distributed numbers.\n| `random`   | Uniformly distributed numbers on `[0,1]`.\n| `normal`   | Normally distributed numbers.\n| `standard_normal` | Normally distributed numbers with mean 0 and standard deviation 1.\n| `exponential` | Exponentially distributed numbers with scale parameter.\n| `standard_exponential` | Exponentially distributed numbers with scale parameter 1.\n\n\n## Exercises\n\n## Additional resources\n\n",
    "supporting": [
      "02-statistical-simulation_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}